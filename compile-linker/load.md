# 可执行文件的装载与进程

## 1.进程虚拟地址空间
在32位平台下4GB虚拟空间，被划分成两部分，其中操作系统本身使用0XC0000000-0XFFFFFFF，共1GB。剩下的0X00000000-0XBFFFFFFF共3GB的空间都是留给进程使用的。原则上讲，进程最多可以使用3GB的虚拟地址，也就是说整个进程在执行的时候，所有的代码、数据包括通过C语言malloc()等方法申请的虚拟空间之和不可以超过3GB。

## 2.装载方式
程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法是将程序运行所需要的指令和数据全部装入内存中，这样程序就可以顺利运行，这就是简单的静态装入办法。后来发现，程序运行时是有局部性原理的，所以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里，这就是动态装入的基本原理。

**覆盖装入**和**页映射**是两种很典型的动态装载方法。原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。
覆盖装入当前以基本被淘汰，不再继续讨论。

### 2.1 页映射
页映射是虚拟存储机制的一部分。页映射也不是一下就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令按照“页”为单位划分成若干个页，以后所有的装载和操作的单位就是页。

假设程序的所有的指令和数据总和为32KB，那么程序被分成8页。将其编号为P0-P7。假设物理内存为16KB。内存无法将程序全部载入。
下面按照动态载入的原理来进行整个装入过程。如果程序刚开始执行时的入口地址在P0，这时发现程序的P0不在内存中，于是将内存F0分配给P0，并且将P0的内容装入F0；运行一段时间以后，程序需要用到P5，于是将P5装入FA；接着把P3和P6分别装入F2和F3。如图所示。         

 ![page_maping&page_loading](https://github.com/KeshawnZhen/mynote/blob/master/compile-linker/pic/page_maping%26page_loading.jpg)

如果这时程序只需要P0、P3、P5和P6这4个页，那么程序就能一直运行下去。但是，如果程序这时需要访问P4，那么就要做出抉择，必须放弃目前正在使用的4个内存页中的某一个来装载P4。至于选择的算法FIFO、LRU等。


## 3.从OS的角度来看可执行文件的装载
由于硬件地址转换和页映射机制的存在，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。
### 3.1进程的建立
从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间。一个程序执行的同时都伴随着一个新的进程的创建。    
创建一个进程，然后装载相应的可执行文件并且执行，在 有虚拟存储的情况下，上述过程需要做三件事：
1. 创建一个独立的虚拟地址空间，
2. 读取可执行文件的头，并且建立虚拟空间与可执行文件的映射关系，
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。

**创建虚拟地址空间**实际上并不是创建空间而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟空间实际上只是分配一个页目录，甚至不设置页映射关系。         
**读取可执行文件的头，并且建立虚拟空间与可执行文件的映射关系**。上面一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射关系。当操作系统捕获到页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。          
**将CPU的指令寄存器设置成可执行文件的入口地址，启动运行**。操作系统通过设置CPU的指令寄存器将控制权交给进程，由此进程开始执行。
### 3.2页错误
上述步骤执行完后，其实可执行文件的真正指令和数据都没有被装入内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。           
假设程序的入口地址为0X08048000，即刚好是.text段的起始地址。当CPU打算执行这个地址的指令时，发现页面0X08048000-0X08049000是个空页面，于是产生一个页错误。CPU将控制权交给操作系统，由操作系统来处理这个情况。             
随着进程的执行，页错误也会不断的产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。
## 4.进程虚存空间分布
操作系统在装载可执行文件时，其只关心一些跟装载相关的问题。最主要的是段的权限（可读、可写、可执行）。ELF文件中，段的属性往往只有为数不多的几种组合。基本上可分为：
1. 以代码段为代表的权限为可读可执行的段。
2. 以数据段和BSS段为代表的权限为可读可写的段。
3. 以只读数据段为代表的权限为只读的段。

一个简单的方案是，对于相同权限的段合并到一起当做一个段进行映射。这样做的好处是可以很明显地减少页面内部碎片，从而节省了内存空间。

```
$ gcc -static SectionMapping.c -o SectionMapping.elf
$ readelf -S SectionMapping.elf 
共有 33 个节头，从偏移量 0xde548 开始：

节头：
  [号] 名称              类型             地址              偏移量
       大小              全体大小          旗标   链接   信息   对齐
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.ABI-tag     NOTE             0000000000400190  00000190
       0000000000000020  0000000000000000   A       0     0     4
  [ 2] .note.gnu.build-i NOTE             00000000004001b0  000001b0
       0000000000000024  0000000000000000   A       0     0     4
  [ 3] .rela.plt         RELA             00000000004001d8  000001d8
       00000000000000f0  0000000000000018  AI       0    24     8
  [ 4] .init             PROGBITS         00000000004002c8  000002c8
       000000000000001a  0000000000000000  AX       0     0     4
  [ 5] .plt              PROGBITS         00000000004002f0  000002f0
       00000000000000a0  0000000000000000  AX       0     0     16
  [ 6] .text             PROGBITS         0000000000400390  00000390
       000000000009e5a4  0000000000000000  AX       0     0     16
  [ 7] __libc_freeres_fn PROGBITS         000000000049e940  0009e940
       0000000000002529  0000000000000000  AX       0     0     16
  [ 8] __libc_thread_fre PROGBITS         00000000004a0e70  000a0e70
       00000000000000de  0000000000000000  AX       0     0     16
  [ 9] .fini             PROGBITS         00000000004a0f50  000a0f50
       0000000000000009  0000000000000000  AX       0     0     4
  [10] .rodata           PROGBITS         00000000004a0f60  000a0f60
       000000000001d244  0000000000000000   A       0     0     32
  [11] __libc_subfreeres PROGBITS         00000000004be1a8  000be1a8
       0000000000000050  0000000000000000   A       0     0     8
  [12] __libc_atexit     PROGBITS         00000000004be1f8  000be1f8
       0000000000000008  0000000000000000   A       0     0     8
  [13] .stapsdt.base     PROGBITS         00000000004be200  000be200
       0000000000000001  0000000000000000   A       0     0     1
  [14] __libc_thread_sub PROGBITS         00000000004be208  000be208
       0000000000000008  0000000000000000   A       0     0     8
  [15] .eh_frame         PROGBITS         00000000004be210  000be210
       000000000000af8c  0000000000000000   A       0     0     8
  [16] .gcc_except_table PROGBITS         00000000004c919c  000c919c
       00000000000000a3  0000000000000000   A       0     0     1
  [17] .tdata            PROGBITS         00000000006c9eb8  000c9eb8
       0000000000000020  0000000000000000 WAT       0     0     8
  [18] .tbss             NOBITS           00000000006c9ed8  000c9ed8
       0000000000000030  0000000000000000 WAT       0     0     8
  [19] .init_array       INIT_ARRAY       00000000006c9ed8  000c9ed8
       0000000000000010  0000000000000000  WA       0     0     8
  [20] .fini_array       FINI_ARRAY       00000000006c9ee8  000c9ee8
       0000000000000010  0000000000000000  WA       0     0     8
  [21] .jcr              PROGBITS         00000000006c9ef8  000c9ef8
       0000000000000008  0000000000000000  WA       0     0     8
  [22] .data.rel.ro      PROGBITS         00000000006c9f00  000c9f00
       00000000000000e4  0000000000000000  WA       0     0     32
  [23] .got              PROGBITS         00000000006c9fe8  000c9fe8
       0000000000000010  0000000000000008  WA       0     0     8
  [24] .got.plt          PROGBITS         00000000006ca000  000ca000
       0000000000000068  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         00000000006ca080  000ca080
       0000000000001ad0  0000000000000000  WA       0     0     32
  [26] .bss              NOBITS           00000000006cbb60  000cbb50
       0000000000001878  0000000000000000  WA       0     0     32
  [27] __libc_freeres_pt NOBITS           00000000006cd3d8  000cbb50
       0000000000000030  0000000000000000  WA       0     0     8
  [28] .comment          PROGBITS         0000000000000000  000cbb50
       0000000000000034  0000000000000001  MS       0     0     1
  [29] .note.stapsdt     NOTE             0000000000000000  000cbb84
       0000000000000f18  0000000000000000           0     0     4
  [30] .shstrtab         STRTAB           0000000000000000  000de3de
       0000000000000169  0000000000000000           0     0     1
  [31] .symtab           SYMTAB           0000000000000000  000ccaa0
       000000000000b0d0  0000000000000018          32   710     8
  [32] .strtab           STRTAB           0000000000000000  000d7b70
       000000000000686e  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

```
使用readelf可以看到，这个执行文件总共有33个段（section）
```
$ readelf -l SectionMapping.elf 

Elf 文件类型为 EXEC (可执行文件)
入口点 0x400890
共有 6 个程序头，开始于偏移量 64

程序头：
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000c923f 0x00000000000c923f  R E    200000
  LOAD           0x00000000000c9eb8 0x00000000006c9eb8 0x00000000006c9eb8
                 0x0000000000001c98 0x0000000000003550  RW     200000
  NOTE           0x0000000000000190 0x0000000000400190 0x0000000000400190
                 0x0000000000000044 0x0000000000000044  R      4
  TLS            0x00000000000c9eb8 0x00000000006c9eb8 0x00000000006c9eb8
                 0x0000000000000020 0x0000000000000050  R      8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10
  GNU_RELRO      0x00000000000c9eb8 0x00000000006c9eb8 0x00000000006c9eb8
                 0x0000000000000148 0x0000000000000148  R      1

 Section to Segment mapping:
  段节...
   00     .note.ABI-tag .note.gnu.build-id .rela.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata __libc_subfreeres __libc_atexit .stapsdt.base __libc_thread_subfreeres .eh_frame .gcc_except_table 
   01     .tdata .init_array .fini_array .jcr .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs 
   02     .note.ABI-tag .note.gnu.build-id 
   03     .tdata .tbss 
   04     
   05     .tdata .init_array .fini_array .jcr .data.rel.ro .got 
```
使用readelf命令来查看ELF的Segment。可以看到这里有6个Segment。从装载的角度来看，只关心两个LOAD类型的Segment，应为他们是要被映射的。

操作系统还通过使用VMA来对进程的地址空间进行管理。进程在执行时需要用到栈和堆等空间。事实上它们在进程的虚拟空间中的表现也是以VMA的形式存在的，很多情况下，一个进程中的栈和堆分别都有一个对应的VMA。在Linux下，可以通过查看“/proc”来查看进程的虚拟空间分布。
```
$cat /proc/processid/maps
$ cat /proc/3431/maps
00400000-004ca000 r-xp 00000000 08:02 3145972                         SectionMapping.elf
006c9000-006cc000 rw-p 000c9000 08:02 3145972                         SectionMapping.elf
006cc000-006ce000 rw-p 00000000 00:00 0 
025ea000-0260d000 rw-p 00000000 00:00 0                                  [heap]
7fff88f5e000-7fff88f7f000 rw-p 00000000 00:00 0                          [stack]
7fff88f7f000-7fff88f82000 r--p 00000000 00:00 0                          [vvar]
7fff88f82000-7fff88f84000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
```
可以看到共有7个VMA，只有前面两个是映射到可执行文件中的两个Segment。另外几个段主设备和次设备的节点号都是0，则表示它们没有映射到文件中，这种VMA叫做匿名虚拟内存区域。可以看到其中两个是堆和栈。

总结一下进程虚拟地址空间的概念：操作系统通过给进程空间划出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下几种VAM区域：
1. 代码VMA，权限只读、可执行；有映像文件。
2. 数据VMA，权限可读写、可执行；有映像文件。
3. 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。
4. 栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。

## 5.Linux内核装载ELF过程简介
在Linux系统的bash下输入一个命令执行某个ELF文件时：
bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束。
```
#include <stdio.h>
#include <sys/>types.h>
#include <unistd.h>

int main()
{
    char buf[1024] = {0};
    pid_t pid;
    while(1) {
        printf("minibash$");
        scanf("%s", buf);
        pid = fork();
        if(pid == 0) {
            if(execlp(buf, 0) < 0>){
                printf("exec error\n");
            }
        }else if (pid > 0){
            int status;
            waitpid(pid, &status, 0);
        }else {
            printf("fork error %d\n", pid);
        }
    }
    return 0;
}
```
在进入execve()调用之后，Linux内核就开始进行真正的装载工作。execve()调用sys_execve()，对参数进行检查复制。然后调用do_execve()，去查找执行文件，并读取执行文件头部，来判断执行文件格式。再然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程。比如ELF文件的load_elf_binary()。             
